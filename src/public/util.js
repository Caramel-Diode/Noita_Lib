const DOMContentLoaded = new Promise((resolve, reject) => window.addEventListener("DOMContentLoaded", resolve));
/** @type {typeof document.createElement} */
const createElement = document.createElement.bind(document);
/** @type {typeof document.createElementNS} */
const createElementNS = document.createElementNS.bind(document);

/**
 * ‰ªéhtmlÂ≠óÁ¨¶‰∏≤ÁîüÊàêÂÖÉÁ¥†
 * * Â∏¶Êúâid ÁöÑÂÖÉÁ¥†ÂèØ‰ªéËøîÂõûÂÄºÁöÑÊàêÂëò‰∏≠Ëé∑Âèñ ÊàêÂëòÂêç‰∏∫`#id`
 * * ÂÖÅËÆ∏ÊèíÂÖ•NodeÁ±ªÂûã
 * * `on-event` Â±ûÊÄßÁªëÂÆö‰∫ã‰ª∂
 * * `style` Â±ûÊÄßÂèØÁî®ÂØπË±°ÂΩ¢ÂºèÊ†∑Âºè
 */
const $html = (() => {
    const parser = new DOMParser();
    /** @returns {Node} */
    return (strings, ...values) => {
        const valueMap = {};
        for (let i = 0; i < values.length; i++) {
            const value = values[i];
            if (typeof value === "object") {
                valueMap[i] = value;
                if (value instanceof Node || Array.isArray(value)) values[i] = `<!--${i}-->`;
                else values[i] = i;
            }
        }
        const doc = parser.parseFromString(`<template>${String.raw(strings, ...values)}</template>`, "text/html");

        /** @type {DocumentFragment} */
        const content = document.adoptNode(doc.head.children[0].content);
        /** @type {Node} */
        let root;
        // Â§ß‰∫é‰∏Ä‰∏™ÂÖÉÁ¥†Êó∂ËøîÂõûÊñáÊ°£ÁâáÊÆµ
        if (content.childNodes.length > 1) root = content;
        else root = content.childNodes[0];
        const iterator = document.createNodeIterator(root);
        let node;
        while ((node = iterator.nextNode()))
            switch (node.nodeType) {
                case node.COMMENT_NODE:
                    const target = valueMap[node.data];
                    if (target) {
                        if (Array.isArray(target)) node.replaceWith(...target);
                        else node.replaceWith(target);
                    }
                    break;
                case node.ELEMENT_NODE:
                    if (node.id) {
                        root["#" + node.id] = node;
                        node.toggleAttribute("id");
                    }
                    if (node.hasAttribute("on-event")) {
                        const listener = valueMap[node.getAttribute("on-event")];
                        if (listener) util.addFeatureTo(node, listener);
                        node.toggleAttribute("on-event");
                    }
                    if (node.hasAttribute("style")) {
                        const style = valueMap[node.getAttribute("style")];
                        if (style) {
                            for (const key in style) {
                                const value = style[key];
                                if (key.startsWith("--")) node.style.setProperty(key, value);
                                else node.style[key] = value;
                            }
                        }
                    }
            }

        return root;
    };
})();

const freeze = Object.freeze;

/** `üîß Â∑•ÂÖ∑ÂåÖ` */
const util = {
    /**
     * ÂêëÂÖÉÁ¥†Ê∑ªÂä†ÊåáÂÆö‰∫§‰∫íÂäüËÉΩ
     * @param {Node} target ÁõÆÊ†áËäÇÁÇπ
     * @param {Listeners} listeners ÁõëÂê¨Âô®
     */
    addFeatureTo(target, listeners) {
        if (listeners.click) target.addEventListener("click", listeners.click);
        if (listeners.keydown) {
            target.setAttribute("tabindex", "0"); // Êó†ÈöúÁ¢ç ÂÖÅËÆ∏tabËÅöÁÑ¶
            target.addEventListener("keydown", listeners.keydown);
        }
    },
    /**
     * Â∞ÜÂõæÂÉè‰∏≠ÁöÑÁôΩËâ≤ÂÉèÁ¥†ÂàáÊç¢‰∏∫ÊåáÂÆöÈ¢úËâ≤
     * @param {ImageData} imageData
     * @param {String} hexColor_str 16ËøõÂà∂Ëâ≤ÂÄº
     */
    setImageDataColor: (imageData, hexColor_str) => {
        console.log(hexColor_str);
        const hexColor_num = parseInt(hexColor_str, 16);
        const R = hexColor_num & 0xff,
            G = (hexColor_num >> 8) & 0xff,
            B = (hexColor_num >> 16) & 0xff,
            A = (hexColor_num >> 24) & 0xff;
        for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i] !== 0) {
                imageData.data[i] = R;
                imageData.data[i + 1] = G;
                imageData.data[i + 2] = B;
                imageData.data[i + 3] = A;
            }
        }
    },
    /**
     * ‰øÆÊîπÊåáÂÆöÂÉèÁ¥†È¢úËâ≤
     * @param {ImageData} imageData ÂõæÂÉèÊï∞ÊçÆ
     * @param {Number} x XÂùêÊ†á
     * @param {Number} y YÂùêÊ†á
     * @param {String} hexColor_str 16ËøõÂà∂Ëâ≤ÂÄº
     */
    setImageDataPixelColor: (imageData, x, y, hexColor_str) => {
        const colorDataIndex = imageData.width * 4 * y + 4 * x;
        const hexColor_num = parseInt(hexColor_str, 16);
        imageData.data[colorDataIndex] = hexColor_num & 0xff; //R
        imageData.data[colorDataIndex + 1] = (hexColor_num >> 8) & 0xff; //G
        imageData.data[colorDataIndex + 2] = (hexColor_num >> 16) & 0xff; //B
        imageData.data[colorDataIndex + 3] = (hexColor_num >> 24) & 0xff; //A
    },
    /** Ëß£ÊûêÁõ∏ÂÖ≥Â∑•ÂÖ∑ */
    parse: {
        errRestult: Object.freeze([]),
        /** üè∑Ô∏è ‰ª§ÁâåÁ±ª */
        Token: class {
            static logData = {
                tokens: [],
                main: [],
                styles: [],
                baseStyle: "border-radius: 2px;padding: 1px 1px;line-height: 20px;",
                init() {
                    this.tokens = [];
                    this.main = [];
                    this.styles = [];
                }
            };
            static log() {
                console.debug(this.logData.main.join(""), ...this.logData.styles);
                console.table(this.logData.tokens, ["type", "index", "data"]);
            }
            /** @type { String } */
            type = "";
            /** @type { String|Number } */
            data = "";
            /** @type { Array < String >} */
            #tempData = [];
            /** @type { String } */
            index = -1;
            /** @type { Object } */
            #enum;
            finish() {
                this.constructor.logData.tokens.push(this);
                if (this.#tempData.length > 0) {
                    let tempData = this.#tempData.join("");
                    if (this.#enum.type === "number") {
                        this.data = Number(tempData);
                    } else {
                        this.data = tempData;
                    }
                    this.#tempData = [];
                }
                const logData = this.constructor.logData;
                if (this.#enum.needBlank) {
                    logData.main.push("%c ");
                    logData.styles.push("line-height: 20px;");
                }
                logData.main.push(`%c${this.data}`);
                logData.styles.push(`${logData.baseStyle}color:${this.#enum.color};font-weight:${this.#enum.fontWeight};background-color:${this.#enum.bgColor};`);
            }
            push(char) {
                this.#tempData.push(char);
            }

            constructor(tokenEnum, index) {
                if (tokenEnum) {
                    this.#enum = tokenEnum;
                    this.type = tokenEnum.id;
                    if (tokenEnum.data) {
                        this.data = tokenEnum.data;
                        this.finish();
                    }
                }
                if (index !== undefined) {
                    this.index = index;
                }
            }
        }
    }
};

embed(`#XML.js`);
embed(`#CSV.js`);

/** ËåÉÂõ¥ÂÄº */
class RangeValue {
    /** ÊòØÂê¶‰∏∫Âõ∫ÂÆöÂÄº */
    isFixed = false;
    /**
     * @overload
     * @param {String} exp ËåÉÂõ¥Ë°®ËææÂºè
     * ÊîØÊåÅ‰ª•‰∏ã‰∏âÁßçË°®Á§∫
     * * `>=min`
     * * `<=max`
     * * `min~max`
     * * `value`
     */

    /**
     * @overload
     * @param {Number} min ÊúÄÂ∞èÂÄº
     * @param {Number} max ÊúÄÂ§ßÂÄº
     */

    /**
     * @overload
     * @param {Number} value Âõ∫ÂÆöÂÄº
     */

    constructor(...args) {
        if (args.length > 1) {
            let [v1, v2] = args;
            if (Number.isFinite(v1)) this.median = v2;
            else if (Number.isFinite(v2)) this.median = v1;
            else this.median = (v1 + v2) / 2;
            if (v1 > v2) [this.max, this.min] = args;
            else if (v1 < v2) [this.min, this.max] = args;
            else {
                this.min = this.max = v1;
                this.isFixed = true;
            }
        } else if (typeof args[0] === "string") {
            /** @type {String} */
            const exp = args[0];
            if (exp.startsWith(">=")) {
                this.median = this.min = Number(exp.slice(2));
                this.max = Infinity;
            } else if (exp.startsWith("<=")) {
                this.median = this.max = Number(exp.slice(2));
                this.min = -Infinity;
            } else if (exp.includes("~")) {
                const [min, max] = exp.split("~");
                this.min = Number(min);
                this.max = Number(max);
                if (this.max < this.min) [this.min, this.max] = [this.max, this.min];
                this.median = (this.min + this.max) / 2;
            } else {
                this.min = this.max = this.median = Number(exp);
                this.isFixed = true;
            }
        } else if (typeof args[0] === "number") {
            this.median = this.min = this.max = args[0];
            this.isFixed = true;
        }
        freeze(this);
    }

    /** @param {String} [unitSymbol] Âçï‰ΩçÁ¨¶Âè∑ */
    toString(unitSymbol = "") {
        if (this.max === Infinity) return "‚â• " + this.min + unitSymbol;
        if (this.min === -Infinity) return "‚â§ " + this.max + unitSymbol;
        if (this.max - this.min) return `${this.min}${unitSymbol} ~ ${this.max}${unitSymbol}`;
        else return this.median + unitSymbol;
    }

    /**
     * ËøîÂõû‰∏Ä‰∏™ÂêåÊ≠•‰øÆÊîπÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄºÁöÑÊñ∞RangeÂØπË±°
     * @param {(value:Number)=>Number} callback
     */
    withChange(callback) {
        return new RangeValue(callback(this.min), callback(this.max));
    }
}

/** Ê∏∏ÊàèÊó∂Èó¥Êç¢ÁÆóÂØπË±° */
class GameTime {
    static toS = f => f / 60;
    static toF = s => Math.round(s * 60);

    $f = 0;
    $s = 0;
    /** @param {Number} f Êó∂Èó¥(Â∏ß) */
    constructor(f) {
        this.$f = f;
        this.$s = f / 60;
        this.f = this.$f + "f";
        this.s = Math.round(this.$s * 100) / 100 + "s";
        freeze(this);
    }
}

/**
 * ### ÂºÇÊ≠•Ëé∑ÂèñÂõæÂÉè
 * @param {String} url ÂèØ‰ª•ÊòØbase64ÊàñËÄÖË∑ØÂæÑ
 * @returns {Promise<HTMLImageElement>}
 */
const asyncImg = async url => {
    const img = new Image();
    img.src = url;
    await img.decode();
    return img;
};

/** Á©∫ÁôΩ 1px * 1px ÂõæÁâá */
const $blankImg = new Promise(resolve => {
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    canvas.toBlob(blob => resolve(URL.createObjectURL(blob)));
});

/**
 * ### ÂºÇÊ≠•Ëé∑ÂèñÁ≤æÁÅµÂõæÁöÑÊãÜÂàÜÂõæÊ†áurl
 * @param {String} url ÂèØ‰ª•ÊòØbase64ÊàñËÄÖË∑ØÂæÑ
 * @returns {Promise<Array<String>>} urlÊï∞ÁªÑ
 */
const asyncSpriteUrls = async url => {
    const img = await asyncImg(url);
    /** @type {ImageEncodeOptions} */
    const options = { type: "image/webp", quality: 1 };
    // ÂõæÊ†á‰∏∫Ê≠£ÊñπÂΩ¢
    const iconSize = img.height;
    // ÂõæÊ†áÊòØÊ∞¥Âπ≥ÊéíÂàóÁöÑ
    const iconAmount = img.width / iconSize;
    const canvas = new OffscreenCanvas(iconSize, iconSize);
    const ctx = canvas.getContext("2d");
    /** @type {Array<String>} */
    const urls = new Array(iconAmount);
    // urls["null"] = await $blankImg;
    for (let i = 0; i < iconAmount; i++) {
        ctx.drawImage(img, -i * iconSize, 0);
        urls[i] = URL.createObjectURL(await canvas.convertToBlob(options));
        ctx.clearRect(0, 0, iconSize, iconSize);
    }
    return urls;
};

const $icon = (() => {
    class Icon extends HTMLImageElement {
        /**
         * @overload
         * @param {Number} height
         * @param {Number} width
         */

        /**
         * @overload
         * @param {Number} size
         */

        /**
         * ‰ªÖÂ°´ÂÜô‰∏Ä‰∏™ÂèÇÊï∞Êó∂ËÆ§‰∏∫ËØ•ÂèÇÊï∞ÂêåÊó∂‰∏∫ÂÆΩÈ´òÁöÑÂÄº
         */
        constructor(width = 1, height = width) {
            super();
            this.width = width;
            this.height = height;
        }
        /**
         * @param {Number} zoom
         * @returns {String}
         */
        base64(zoom = 1) {
            const _w = this.naturalWidth * zoom,
                _h = this.naturalHeight * zoom,
                w = this.naturalWidth,
                h = this.naturalHeight;
            const canvas = document.createElement("canvas");
            canvas.width = _w;
            canvas.height = _h;
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(this, 0, 0, w, h, 0, 0, _w, _h);
            return canvas.toDataURL("image/png");
        }

        static $defineElement(name) {
            customElements.define("noita-" + name, this, { extends: "img" });
        }
    }
    return (size, altTag) => {
        altTag = altTag + "ÂõæÊ†á:";
        return class extends Icon {
            #alt;
            constructor() {
                super(size);
            }
            /** @param {Promise<String>} url */
            set src(url) {
                url.then(v => {
                    if (v) {
                        this.decoding = "async";
                        // this.loading = "lazy";
                        this.style.imageRendering = "pixelated";
                        super.alt = this.#alt;
                        super.src = v;
                    } else this.hidden = true;
                });
            }
            set alt(value) {
                this.#alt = altTag + value;
            }
        };
    };
})();

// const base64 = {
//     /**
//      * Â∞ÜBase64ËΩ¨‰∏∫FileÂØπË±°
//      * @param {String} data base64Êï∞ÊçÆÊñáÊú¨
//      * @param {String} fileName
//      * @returns {File}
//      */
//     toFile(data, fileName) {
//         const arr = data.split(",");
//         const type = arr[0].match(/:(.*?);/)[1];
//         const StringData = atob(arr[1]);
//         let i = StringData.length;
//         const U8ArrayData = new Uint8Array(i);
//         while (i--) U8ArrayData[i] = StringData.charCodeAt(i);
//         return new File([U8ArrayData], fileName, { type });
//     },
//     /**
//      * Â∞ÜBase64ËΩ¨‰∏∫URL
//      * @param {String} data base64Êï∞ÊçÆÊñáÊú¨
//      * @param {String} fileName Êñá‰ª∂Âêç
//      * @returns {String}
//      */
//     toObjectURL(data, fileName = "") {
//         return URL.createObjectURL(this.toFile(data, fileName));
//     }
// };

const math_ = {
    /**
     * ÂõõËàç‰∫îÂÖ•‰øùÁïôxÂ∞èÊï∞
     * @param {Number} num
     * @param {Number} [x] ÊúÄÂ§ö‰øùÁïôÁöÑÂ∞èÊï∞‰ΩçÊï∞ ÈªòËÆ§‰øùÁïô‰∏§‰Ωç
     * @returns {Number}
     */
    roundTo(num, x = 2) {
        const t = Math.pow(10, x);
        return Math.round(num * t) / t;
    },
    /**
     * ‰ª•ÂºßÂ∫¶‰∏∫Âçï‰ΩçËΩ¨Êç¢‰∏∫‰ª•ËßíÂ∫¶‰∏∫Âçï‰Ωç
     * @param {Number} rad ÂºßÂ∫¶
     * @returns {Number} ËßíÂ∫¶
     */
    radianToDegree: rad => (rad * 180) / Math.PI,
    /**
     * Ëé∑Âèñ‰ª• **Â∫¶**`¬∞`**ÂàÜ**`‚Ä≤`**Áßí**`‚Ä≥` Ë°®Á§∫ÁöÑÁ≤æÁ°ÆËßíÂ∫¶
     * @param {Number} deg ËßíÂ∫¶
     * @param {Boolean} [needSign=false] ÊòØÂê¶ÈúÄË¶ÅÂâçÁºÄ`+`
     * @returns {String} ÁªìÊûú
     */
    getExactDegree(deg, needSign = false) {
        let temp1 = 0;
        let temp2 = 0;
        const temp3 = [];
        const value_temp = Math.abs(deg);
        const _d = Math.trunc(value_temp);
        temp1 = value_temp - _d;
        temp2 = temp1 * 60;
        const _m = Math.trunc(temp2);
        temp1 = temp2 - _m;
        const _s = Math.trunc(temp1 * 60);

        if (_d !== 0) temp3.push(_d, "¬∞");
        if (_m !== 0) temp3.push(_m, "‚Ä≤");
        if (_s !== 0) temp3.push(_s, "‚Ä≥");
        let temp4 = temp3.join("");
        if (deg < 0) temp4 = "-".concat(temp4);
        else if (needSign) temp4 = "+".concat(temp4);

        return temp4;
    },
    /**
     * ‰ª•Â∏ß‰∏∫Âçï‰ΩçËΩ¨Êç¢‰∏∫‰ª•Áßí‰∏∫Âçï‰Ωç 60Â∏ßÊØèÁßí ÁªìÊûú‰øùÁïô‰∏§‰ΩçÂ∞èÊï∞
     * @param {Number} frame Â∏ß
     * @returns {Number} Áßí
     */
    frameToSecond: frame => Math.round(frame / 0.6) / 100,
    /**
     * Ëé∑ÂæóÂ§πÈÄºÂêéÁöÑÂÄº
     * @param {Number} value ÂæÖÂ§πÈÄºÁöÑÂÄº
     * @param {Number} min ÊúÄÂ∞èÂÄº
     * @param {Number} max ÊúÄÂ§ßÂÄº
     * @returns Â§πÈÄºÂêéÁöÑÂÄº
     */
    clamp: (value, min, max) => Math.min(Math.max(value, min), max),
    /**
     * ËøîÂõûÈöèÊú∫Êï∞
     * @param  {...Number} param Âçï‰∏™ÂèÇÊï∞Êó∂ËøîÂõû 0Âà∞ÊîπÂèÇÊï∞‰πãÈó¥ÁöÑÈöèÊú∫ÂÄº ‰∏§‰∏™ÂèÇÊï∞Êó∂ËøîÂõû‰∏§‰∏™ÂèÇÊï∞‰πãÈó¥ÁöÑÂÄº
     * @returns {Number} ÈöèÊú∫Êï¥Êï∞
     */
    random(...param) {
        if (param.length === 1) {
            if (param[0]) return Math.round(Math.random() * param[0]);
            else return 0;
        } else {
            let min, max;
            if (param[0] > param[1]) {
                max = param[0];
                min = param[1];
            } else if (param[0] < param[1]) {
                max = param[1];
                min = param[0];
            } else return param[0];
            return Math.round(Math.random() * (max - min) + min);
        }
    },
    /**
     * ÈöèÊú∫ÂàÜÂ∏É
     * @param {Number} min ÊúÄÂ∞èÂÄº
     * @param {Number} max ÊúÄÂ§ßÂÄº
     * @param {Number} mean Âπ≥ÂùáÂÄº
     * @param {Number} sharpness ÈîêÂ∫¶
     * @param {Number} baseline Âü∫Á∫ø
     * @returns {Number}
     */
    randomDistribution(min, max, mean, sharpness = 1, baseline = 0.005) {
        if (min < max && mean > min && mean < max) {
            let val = ((Math.random() - baseline) / (1 - baseline)) * (max - min) + min;
            return val;
        } else {
            console.error(new Error("ÂèÇÊï∞ÈùûÊ≥ï"));
            return NaN;
        }
    },
    /**
     * **Ê¥óÁâå** Êâì‰π±Êï∞ÁªÑÈ°∫Â∫è
     * @param {Array} array
     */
    shuffle(array) {
        if (array.length > 1) {
            for (let i = array.length; i > 0; i--) {
                let j = this.random(0, i);
                const temp = array[j];
                array[j] = array[i];
                array[i] = temp;
            }
        }
    }
};

/**
 * ÁîüÊàêÊ†∑ÂºèË°®
 * *generateCSSStyleSheet*
 * @param {String} rules CSSËßÑÂàôË°®Â≠óÁ¨¶‰∏≤
 * @returns {CSSStyleSheet} CSSÊ†∑ÂºèË°®
 */
const gss = rules => {
    const css = new CSSStyleSheet();
    css.replaceSync(rules);
    return css;
};

const $symbols = {
    initStyle: Symbol("init-style")
};

/**
 * @template {String} V
 * @typedef $ValueOption ËÆøÈóÆ/ËÆæÁΩÆÂô®ÈÖçÁΩÆ
 * @prop {String} name HTML Â±ûÊÄßÂêç `<E name="">`
 * @prop {V} [$default] ÈªòËÆ§Â±ûÊÄßÂÄº
 * @prop {Boolean} [needObserve=true] ÈúÄË¶ÅÁõëÊéßÂèòÂåñ
 * @prop {V} [$type] ÂêàÊ≥ïÂÄº(‰ªÖ‰Ωú‰∏∫Ê≥õÂûãÂèÇÊï∞ ‰∏çÈúÄË¶Å‰º†ÂÖ•)
 */

/**
 * ‰∏∫ÊûÑÈÄ†Âô®ÂàõÂª∫Â≠êÁ±ªÊûÑÈÄ†Âô®Âπ∂ËøîÂõû
 * * Â∞ÜÂ≠êÁ±ªÁöÑ`prototype`Ê∑ªÂä†`getter`, `setter`
 * * Â∞ÜÂ±ûÊÄßÊ∑ªÂä†Âà∞Ë¢´ËßÇÂØüÂàóË°®‰∏≠ `observedAttributes`
 * @template {{ [key:string]: $ValueOption }} T
 * @template {Function} C
 * @param {C} constructor ÊûÑÈÄ†Âô®
 * @param {T} propAttrMap objectProp‰∏éHTMLAttributeÁöÑÊò†Â∞ÑË°®
 * @returns {C & {
 *     observedAttributes: Readonly<[keyof T]>
 * }}
 */
//prettier-ignore
const $class = (constructor, propAttrMap) => class extends constructor {
    static observedAttributes = [];
    static {
        for (const prop in propAttrMap) {
            const { name, $default, needObserve = true } = propAttrMap[prop];
            if (needObserve) this.observedAttributes.push(name);
            Object.defineProperty(this.prototype, prop, {
                //prettier-ignore
                get() { return this.hasAttribute(name) ? this.getAttribute(name) : $default; },
                set(value = null) {
                    if (value === null) this.removeAttribute(name);
                    else {
                        //Èò≤Ê≠¢È¶ñÊ¨°ËÆæÁΩÆÂ±ûÊÄß‰∏çËÉΩËá™Âä®Êõ¥Êñ∞ÂÜÖÂÆπ
                        if (!this.hasAttribute(name)) this.setAttribute(name, "");
                        this.setAttribute(name, value);
                    }
                }
            });
        }
        freeze(this.observedAttributes);
        freeze(this);
    }
};
