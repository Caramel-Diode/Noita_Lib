/**
 * 获取注释文本
 */
const getCommentText = data => `/*
 * Generated by parseTools.spell
 * ${new Date().toLocaleString()}
 * form "data/scripts/gun/gun_actions.lua"
 * ${data}
 */
//prettier-ignore`;

const zh_cn = langData.getZH_CN;

class Spell {
    static typeEmojis = ["⚫", "🔴", "🟠", "🔵", "⚪", "🟢", "🟡", "🟣", "🟤"];
    id;
    name;
    alias;
    desc;
    type;
    maxUse;
    neverUnlimited;
    mana;
    price;
    passiveEffect;
    spwanLevel;
    spawnProb;
    spawnRequiresFlag = "";
    draw;
    fireRateWait;
    damageCriticalChance;
    explosionRadius;
    spreadDegrees;
    patternDegrees;
    speedMultiplier;
    childSpeedMultiplier;
    lifetime;
    bounces;
    knockbackForce = 0;
    friendlyFire;
    screenshake;
    lightningCount;
    gravity;
    recoilKnockback;
    reloadTime;
    material;
    materialAmount;
    trailMaterial;
    trailMaterialAmount;
    extraEntities = "";
    gameEffectEntities = "";
    damageMod;
    projectiles;
    action = "";
    nameKey;
    descKey;
    /** @type {CSVData} 别名表 */
    static _aliasCSV;
    /** @type {CSVData} 解锁描述表 */
    static _unlockDescCSV;
    /** @type {CSVData} 被动效果描述表 */
    static _passiveDescCSV;
    /** @type {CSVData} (额外)提供投射物表 */
    static _projectileCSV;
    /** @param {spellBaseData} data */
    constructor(data) {
        if (data.name.startsWith("$")) {
            this.nameKey = data.name.slice(1);
            this.name = zh_cn(this.nameKey) ?? this.nameKey;
        } else {
            this.nameKey = data.name;
            this.name = data.name;
        }
        if (data.desc.startsWith("$")) {
            this.descKey = data.desc.slice(1);
            this.desc = zh_cn(this.descKey) ?? this.descKey;
        } else {
            this.descKey = data.desc;
            this.desc = data.desc;
        }
        this.alias = Spell._aliasCSV.get(this.name, 1) ?? "";
        if (data.spawnRequiresFlag) {
            const unlockDesc = Spell._unlockDescCSV.get(data.id, 2);
            if (unlockDesc) this.spawnRequiresFlag = unlockDesc;
            else {
                this.spawnRequiresFlag = data.spawnRequiresFlag;
                console.warn(`解锁条件描述缺失 ${data.id}:${data.name}`);
            }
        }
        if (data.passiveEffect) {
            const passiveDesc = Spell._passiveDescCSV.get(data.id, 2);
            if (passiveDesc) this.passiveEffect = passiveDesc;
            else {
                this.passiveEffect = "";
                console.warn(`被动效果描述缺失 ${data.id}:${data.name}`);
            }
        }

        // 提供投射物 转为表达式
        // 格式: 投射物实体ID:数量H碰撞触发抽取数D失效触发抽取数T定时触发抽取数!定时触发延迟时间#提供类型
        const projectilesCache = [];

        /** 关联投射物xml */
        const relatedProjectileName = data.relatedProjectiles?.[0];
        const relatedProjectileAmount = data.relatedProjectiles?.[1] ?? 1;
        let relatedProjectileHasBeenAdded = false; // 防止重复被添加
        for (let i = 0; i < data.projectiles.length; i++) {
            const p = data.projectiles[i];
            const id = p.id.match(/[\w]+(?=.xml)/)[0].toUpperCase();
            const cache = [id];

            if (p.min + p.draw_hit + p.draw_death + p.draw_time_count > 1) {
                cache.push(":");
                if (p.min > 1) cache.push(p.min);
                if (p.draw_hit) cache.push("H", p.draw_hit);
                if (p.draw_death) cache.push("D", p.draw_death);
                if (p.draw_time_count) cache.push("T", p.draw_time_count, "!", p.draw_time_delay);
            }
            // 与关联投射物xml不相同或者数量不同时单独声明关联投射物 (蠕虫雨, 召唤虫子系列, 侵扰)
            if (p.id !== relatedProjectileName || p.min !== relatedProjectileAmount) {
                if (!cache.includes(":")) cache.push(":");
                cache.push(`#2`); //提供类型为仅施法块
                projectilesCache.push(cache.join(""));
            } else projectilesCache.push(cache.join(""));

            /* 关联投射物必须存在 */
            if (relatedProjectileName && relatedProjectileName === p.id) {
                relatedProjectileHasBeenAdded = true;
                // 关联投射物数量与施法块投射物数量不一致时(召唤虫子系列, 侵扰)
                if (p.min !== relatedProjectileAmount) {
                    if (relatedProjectileAmount > 1) projectilesCache.push(`${id}:${relatedProjectileAmount}#1`);
                    else projectilesCache.push(`${id}:#1`);
                }
            }
        }
        if (!relatedProjectileHasBeenAdded && relatedProjectileName) {
            const id = relatedProjectileName.match(/[\w]+(?=.xml)/)[0].toUpperCase();
            if (relatedProjectileAmount > 1) projectilesCache.push(`${id}:${relatedProjectileAmount}#1`);
            else projectilesCache.push(`${id}:#1`);
        }
        projectilesCache.push(Spell._projectileCSV.get(data.id, 2) ?? "");
        this.projectiles = projectilesCache.join(" ").trimEnd();

        this.damageMod = Object.assign(new DamageData(""), data.damageMod).toString();
        if (data.gameEffectEntities) this.gameEffectEntities = data.gameEffectEntities.match(/[\w]+(?=.xml)/)[0].toUpperCase();
        if (data.extraEntities) this.extraEntities = data.extraEntities.match(/[\w]+(?=.xml)/)[0].toUpperCase();
        this.id = data.id;
        this.type = data.type;
        this.maxUse = data.maxUse ?? -1;
        this.neverUnlimited = data.neverUnlimited;
        this.mana = data.mana ?? 10; // 蓝耗默认为10
        this.price = data.price;
        this.spwanLevel = data.spwanLevel;
        this.spawnProb = data.spawnProb;
        this.draw = data.draw;
        this.fireRateWait = data.fireRateWait;
        this.damageCriticalChance = data.damageCriticalChance;
        this.explosionRadius = data.explosionRadius;
        this.spreadDegrees = data.spreadDegrees;
        this.patternDegrees = data.patternDegrees;
        this.speedMultiplier = data.speedMultiplier;
        this.childSpeedMultiplier = data.childSpeedMultiplier;
        this.lifetime = data.lifetime;
        this.bounces = data.bounces;
        this.knockbackForce = this.knockbackForce;
        this.friendlyFire = data.friendlyFire;
        this.screenshake = data.screenshake;
        this.lightningCount = data.lightningCount;
        this.gravity = data.gravity;
        this.recoilKnockback = data.recoilKnockback;
        this.reloadTime = data.reloadTime;
        this.material = data.material;
        this.materialAmount = data.materialAmount;
        this.trailMaterial = data.trailMaterial;
        this.trailMaterialAmount = data.trailMaterialAmount;
    }

    toString() {
        // console.error(this.name, this);
        return JSON5.stringify([
            //============================[构造器数据索引]
            this.id, //======================[0] id
            this.name, //====================[1] 名称
            this.alias, //===================[2] 别名
            this.desc, //====================[3] 描述
            this.type, //====================[4] 类型
            this.maxUse, //==================[5] 最大使用次数
            this.neverUnlimited, //==========[6] 禁止无限化
            this.mana, //====================[7] 蓝耗
            this.price, //===================[8] 售价
            this.passiveEffect ?? "", //=====[9] 被动效果
            this.spwanLevel, //==============[10] 生成等级
            this.spawnProb, //===============[11] 生成概率
            this.spawnRequiresFlag ?? "", //=[12] 生成条件
            this.draw, //====================[13] 抽取数
            this.fireRateWait, //============[14] 施放延迟
            this.damageCriticalChance, //====[15] 暴击率
            this.explosionRadius, //=========[16] 爆炸半径
            this.spreadDegrees, //===========[17] 散射
            this.patternDegrees, //==========[18] 阵型分布
            this.speedMultiplier, //=========[19] 投射物速度
            this.childSpeedMultiplier, //====[20] 投射物子速度
            this.lifetime, //================[21] 存在时间
            this.bounces, //=================[22] 弹跳次数
            this.knockbackForce, //==========[23] 击退力度
            this.friendlyFire, //============[24] 友伤
            this.screenshake, //=============[25] 抖屏力度
            this.lightningCount, //==========[26] 电弧数量
            this.gravity, //=================[27] 重力系数
            this.recoilKnockback, //=========[28] 后座力
            this.reloadTime, //==============[29] 充能时间
            this.material, //================[30] 材料类型
            this.materialAmount, //==========[31] 材料数量
            this.trailMaterial, //===========[32] 轨迹材料
            this.trailMaterialAmount, //=====[33] 轨迹材料数量
            this.extraEntities, //===========[34] 额外实体
            this.gameEffectEntities, //======[35] 游戏效果实体
            this.damageMod, //===============[36] 伤害修正
            this.projectiles, //=============[37] 提供投射物
            this.action, //==================[38] 法术行为
            this.nameKey, //=================[39] 名称键 用于csv翻译映射
            this.descKey //==================[40] 描述键 用于csv翻译映射
        ]);
    }
}

(async () => {
    Spell._aliasCSV = await parseCSVFromUrl("alias.csv");
    Spell._unlockDescCSV = await parseCSVFromUrl("unlockDesc.csv");
    Spell._passiveDescCSV = await parseCSVFromUrl("passiveDesc.csv");
    Spell._projectileCSV = await parseCSVFromUrl("projectile.csv");
    /** @type {HTMLButtonElement} */
    const button = document.querySelector(`#gen-data`);
    const buttonText = button.innerText;
    button.innerText = "Loading";
    const imgs = await Promise.all(spellBaseDatas.map(e => PNG.removeGAMA(`/${e.icon}`)));

    const canvas = await createSprite(imgs, { size: 16 });
    document.querySelector("#canvas-viewport").append(canvas);
    button.addEventListener("click", async () => {
        const data = spellBaseDatas.map(e => new Spell(e));
        console.log(data);
        const fileContent = `${getCommentText(`共${spellBaseDatas.length}条法术数据`)}\n[\n    ${data.join(",\n    ")}\n]`;
        download(fileContent, "spell.data.js");
        const cache = [];
        for (let i = 0; i < data.length; i++) {
            const d = data[i];
            const base64 = await urlToBase64(imgs[i], 2);
            let alias = "";

            if (d.alias)
                alias = `${d.alias
                    .split(" ")
                    .map(e => `\`${e}\``)
                    .join(",")}`;
            cache.push(`{"name":"${d.id}","description":"**\`${Spell.typeEmojis[d.type]}${d.name}\`**  \\n![](${base64})  \\n${alias}"}`);
        }
        console.log(cache.join(",\n"));
    });
    button.innerText = buttonText;
})();

console.log(newData);