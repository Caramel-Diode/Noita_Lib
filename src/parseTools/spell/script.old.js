/**
 * è·å–æ³¨é‡Šæ–‡æœ¬
 */
const getCommentText = data => `/*
 * Generated by parseTools.spell
 * ${new Date().toLocaleString()}
 * form "data/scripts/gun/gun_actions.lua"
 * ${data}
 */
//prettier-ignore`;

const zh_cn = langData.getZH_CN;

class Spell {
    static typeEmojis = ["âš«", "ğŸ”´", "ğŸŸ ", "ğŸ”µ", "âšª", "ğŸŸ¢", "ğŸŸ¡", "ğŸŸ£", "ğŸŸ¤"];
    id;
    name;
    alias;
    desc;
    type;
    maxUse;
    neverUnlimited;
    mana;
    price;
    passiveEffect;
    spwanLevel;
    spawnProb;
    spawnRequiresFlag = "";
    draw;
    fireRateWait;
    damageCriticalChance;
    explosionRadius;
    spreadDegrees;
    patternDegrees;
    speedMultiplier;
    childSpeedMultiplier;
    lifetime;
    bounces;
    knockbackForce = 0;
    friendlyFire;
    screenshake;
    lightningCount;
    gravity;
    recoilKnockback;
    reloadTime;
    material;
    materialAmount;
    trailMaterial;
    trailMaterialAmount;
    extraEntities = "";
    gameEffectEntities = "";
    damageMod;
    projectiles;
    action = "";
    nameKey;
    descKey;
    /** @type {CSVData} åˆ«åè¡¨ */
    static _aliasCSV;
    /** @type {CSVData} è§£é”æè¿°è¡¨ */
    static _unlockDescCSV;
    /** @type {CSVData} è¢«åŠ¨æ•ˆæœæè¿°è¡¨ */
    static _passiveDescCSV;
    /** @type {CSVData} (é¢å¤–)æä¾›æŠ•å°„ç‰©è¡¨ */
    static _projectileCSV;
    /** @param {spellBaseData} data */
    constructor(data) {
        if (data.name.startsWith("$")) {
            this.nameKey = data.name.slice(1);
            this.name = zh_cn(this.nameKey) ?? this.nameKey;
        } else {
            this.nameKey = data.name;
            this.name = data.name;
        }
        if (data.desc.startsWith("$")) {
            this.descKey = data.desc.slice(1);
            this.desc = zh_cn(this.descKey) ?? this.descKey;
        } else {
            this.descKey = data.desc;
            this.desc = data.desc;
        }
        this.alias = Spell._aliasCSV.get(this.name, 1) ?? "";
        if (data.spawnRequiresFlag) {
            const unlockDesc = Spell._unlockDescCSV.get(data.id, 2);
            if (unlockDesc) this.spawnRequiresFlag = unlockDesc;
            else {
                this.spawnRequiresFlag = data.spawnRequiresFlag;
                console.warn(`è§£é”æ¡ä»¶æè¿°ç¼ºå¤± ${data.id}:${data.name}`);
            }
        }
        if (data.passiveEffect) {
            const passiveDesc = Spell._passiveDescCSV.get(data.id, 2);
            if (passiveDesc) this.passiveEffect = passiveDesc;
            else {
                this.passiveEffect = "";
                console.warn(`è¢«åŠ¨æ•ˆæœæè¿°ç¼ºå¤± ${data.id}:${data.name}`);
            }
        }

        // æä¾›æŠ•å°„ç‰© è½¬ä¸ºè¡¨è¾¾å¼
        // æ ¼å¼: æŠ•å°„ç‰©å®ä½“ID:æ•°é‡Hç¢°æ’è§¦å‘æŠ½å–æ•°Då¤±æ•ˆè§¦å‘æŠ½å–æ•°Tå®šæ—¶è§¦å‘æŠ½å–æ•°!å®šæ—¶è§¦å‘å»¶è¿Ÿæ—¶é—´#æä¾›ç±»å‹
        const projectilesCache = [];

        /** å…³è”æŠ•å°„ç‰©xml */
        const relatedProjectileName = data.relatedProjectiles?.[0];
        const relatedProjectileAmount = data.relatedProjectiles?.[1] ?? 1;
        let relatedProjectileHasBeenAdded = false; // é˜²æ­¢é‡å¤è¢«æ·»åŠ 
        for (let i = 0; i < data.projectiles.length; i++) {
            const p = data.projectiles[i];
            const id = p.id.match(/[\w]+(?=.xml)/)[0].toUpperCase();
            const cache = [id];

            if (p.min + p.draw_hit + p.draw_death + p.draw_time_count > 1) {
                cache.push(":");
                if (p.min > 1) cache.push(p.min);
                if (p.draw_hit) cache.push("H", p.draw_hit);
                if (p.draw_death) cache.push("D", p.draw_death);
                if (p.draw_time_count) cache.push("T", p.draw_time_count, "!", p.draw_time_delay);
            }
            // ä¸å…³è”æŠ•å°„ç‰©xmlä¸ç›¸åŒæˆ–è€…æ•°é‡ä¸åŒæ—¶å•ç‹¬å£°æ˜å…³è”æŠ•å°„ç‰© (è •è™«é›¨, å¬å”¤è™«å­ç³»åˆ—, ä¾µæ‰°)
            if (p.id !== relatedProjectileName || p.min !== relatedProjectileAmount) {
                if (!cache.includes(":")) cache.push(":");
                cache.push(`#2`); //æä¾›ç±»å‹ä¸ºä»…æ–½æ³•å—
                projectilesCache.push(cache.join(""));
            } else projectilesCache.push(cache.join(""));

            /* å…³è”æŠ•å°„ç‰©å¿…é¡»å­˜åœ¨ */
            if (relatedProjectileName && relatedProjectileName === p.id) {
                relatedProjectileHasBeenAdded = true;
                // å…³è”æŠ•å°„ç‰©æ•°é‡ä¸æ–½æ³•å—æŠ•å°„ç‰©æ•°é‡ä¸ä¸€è‡´æ—¶(å¬å”¤è™«å­ç³»åˆ—, ä¾µæ‰°)
                if (p.min !== relatedProjectileAmount) {
                    if (relatedProjectileAmount > 1) projectilesCache.push(`${id}:${relatedProjectileAmount}#1`);
                    else projectilesCache.push(`${id}:#1`);
                }
            }
        }
        if (!relatedProjectileHasBeenAdded && relatedProjectileName) {
            const id = relatedProjectileName.match(/[\w]+(?=.xml)/)[0].toUpperCase();
            if (relatedProjectileAmount > 1) projectilesCache.push(`${id}:${relatedProjectileAmount}#1`);
            else projectilesCache.push(`${id}:#1`);
        }
        projectilesCache.push(Spell._projectileCSV.get(data.id, 2) ?? "");
        this.projectiles = projectilesCache.join(" ").trimEnd();

        this.damageMod = Object.assign(new DamageData(""), data.damageMod).toString();
        if (data.gameEffectEntities) this.gameEffectEntities = data.gameEffectEntities.match(/[\w]+(?=.xml)/)[0].toUpperCase();
        if (data.extraEntities) this.extraEntities = data.extraEntities.match(/[\w]+(?=.xml)/)[0].toUpperCase();
        this.id = data.id;
        this.type = data.type;
        this.maxUse = data.maxUse ?? -1;
        this.neverUnlimited = data.neverUnlimited;
        this.mana = data.mana ?? 10; // è“è€—é»˜è®¤ä¸º10
        this.price = data.price;
        this.spwanLevel = data.spwanLevel;
        this.spawnProb = data.spawnProb;
        this.draw = data.draw;
        this.fireRateWait = data.fireRateWait;
        this.damageCriticalChance = data.damageCriticalChance;
        this.explosionRadius = data.explosionRadius;
        this.spreadDegrees = data.spreadDegrees;
        this.patternDegrees = data.patternDegrees;
        this.speedMultiplier = data.speedMultiplier;
        this.childSpeedMultiplier = data.childSpeedMultiplier;
        this.lifetime = data.lifetime;
        this.bounces = data.bounces;
        this.knockbackForce = this.knockbackForce;
        this.friendlyFire = data.friendlyFire;
        this.screenshake = data.screenshake;
        this.lightningCount = data.lightningCount;
        this.gravity = data.gravity;
        this.recoilKnockback = data.recoilKnockback;
        this.reloadTime = data.reloadTime;
        this.material = data.material;
        this.materialAmount = data.materialAmount;
        this.trailMaterial = data.trailMaterial;
        this.trailMaterialAmount = data.trailMaterialAmount;
    }

    toString() {
        // console.error(this.name, this);
        return JSON5.stringify([
            //============================[æ„é€ å™¨æ•°æ®ç´¢å¼•]
            this.id, //======================[0] id
            this.name, //====================[1] åç§°
            this.alias, //===================[2] åˆ«å
            this.desc, //====================[3] æè¿°
            this.type, //====================[4] ç±»å‹
            this.maxUse, //==================[5] æœ€å¤§ä½¿ç”¨æ¬¡æ•°
            this.neverUnlimited, //==========[6] ç¦æ­¢æ— é™åŒ–
            this.mana, //====================[7] è“è€—
            this.price, //===================[8] å”®ä»·
            this.passiveEffect ?? "", //=====[9] è¢«åŠ¨æ•ˆæœ
            this.spwanLevel, //==============[10] ç”Ÿæˆç­‰çº§
            this.spawnProb, //===============[11] ç”Ÿæˆæ¦‚ç‡
            this.spawnRequiresFlag ?? "", //=[12] ç”Ÿæˆæ¡ä»¶
            this.draw, //====================[13] æŠ½å–æ•°
            this.fireRateWait, //============[14] æ–½æ”¾å»¶è¿Ÿ
            this.damageCriticalChance, //====[15] æš´å‡»ç‡
            this.explosionRadius, //=========[16] çˆ†ç‚¸åŠå¾„
            this.spreadDegrees, //===========[17] æ•£å°„
            this.patternDegrees, //==========[18] é˜µå‹åˆ†å¸ƒ
            this.speedMultiplier, //=========[19] æŠ•å°„ç‰©é€Ÿåº¦
            this.childSpeedMultiplier, //====[20] æŠ•å°„ç‰©å­é€Ÿåº¦
            this.lifetime, //================[21] å­˜åœ¨æ—¶é—´
            this.bounces, //=================[22] å¼¹è·³æ¬¡æ•°
            this.knockbackForce, //==========[23] å‡»é€€åŠ›åº¦
            this.friendlyFire, //============[24] å‹ä¼¤
            this.screenshake, //=============[25] æŠ–å±åŠ›åº¦
            this.lightningCount, //==========[26] ç”µå¼§æ•°é‡
            this.gravity, //=================[27] é‡åŠ›ç³»æ•°
            this.recoilKnockback, //=========[28] ååº§åŠ›
            this.reloadTime, //==============[29] å……èƒ½æ—¶é—´
            this.material, //================[30] ææ–™ç±»å‹
            this.materialAmount, //==========[31] ææ–™æ•°é‡
            this.trailMaterial, //===========[32] è½¨è¿¹ææ–™
            this.trailMaterialAmount, //=====[33] è½¨è¿¹ææ–™æ•°é‡
            this.extraEntities, //===========[34] é¢å¤–å®ä½“
            this.gameEffectEntities, //======[35] æ¸¸æˆæ•ˆæœå®ä½“
            this.damageMod, //===============[36] ä¼¤å®³ä¿®æ­£
            this.projectiles, //=============[37] æä¾›æŠ•å°„ç‰©
            this.action, //==================[38] æ³•æœ¯è¡Œä¸º
            this.nameKey, //=================[39] åç§°é”® ç”¨äºcsvç¿»è¯‘æ˜ å°„
            this.descKey //==================[40] æè¿°é”® ç”¨äºcsvç¿»è¯‘æ˜ å°„
        ]);
    }
}

(async () => {
    Spell._aliasCSV = await parseCSVFromUrl("alias.csv");
    Spell._unlockDescCSV = await parseCSVFromUrl("unlockDesc.csv");
    Spell._passiveDescCSV = await parseCSVFromUrl("passiveDesc.csv");
    Spell._projectileCSV = await parseCSVFromUrl("projectile.csv");
    /** @type {HTMLButtonElement} */
    const button = document.querySelector(`#gen-data`);
    const buttonText = button.innerText;
    button.innerText = "Loading";
    const imgs = await Promise.all(spellBaseDatas.map(e => PNG.removeGAMA(`/${e.icon}`)));

    const canvas = await createSprite(imgs, { size: 16 });
    document.querySelector("#canvas-viewport").append(canvas);
    button.addEventListener("click", async () => {
        const data = spellBaseDatas.map(e => new Spell(e));
        console.log(data);
        const fileContent = `${getCommentText(`å…±${spellBaseDatas.length}æ¡æ³•æœ¯æ•°æ®`)}\n[\n    ${data.join(",\n    ")}\n]`;
        download(fileContent, "spell.data.js");
        const cache = [];
        for (let i = 0; i < data.length; i++) {
            const d = data[i];
            const base64 = await urlToBase64(imgs[i], 2);
            let alias = "";

            if (d.alias)
                alias = `${d.alias
                    .split(" ")
                    .map(e => `\`${e}\``)
                    .join(",")}`;
            cache.push(`{"name":"${d.id}","description":"**\`${Spell.typeEmojis[d.type]}${d.name}\`**  \\n![](${base64})  \\n${alias}"}`);
        }
        console.log(cache.join(",\n"));
    });
    button.innerText = buttonText;
})();

console.log(newData);