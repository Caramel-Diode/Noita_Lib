/**
 * è·å–æ³¨é‡Šæ–‡æœ¬
 */
const getCommentText = data => `/*
 * Generated by parseTools.spell
 * ${new Date().toLocaleString()}
 * form "data/scripts/gun/gun_actions.lua"
 * ${data}
 */
//prettier-ignore`;

const zh_cn = langData.getZH_CN;
const blank = Symbol("");
/**
 * æœ€å°åŒ–xmlè·¯å¾„
 * @param {String} path
 */
const minPath = path => {
    let paths = path.split(",").map(p => p.replace("data/entities/", "").replace(".xml", ""));
    paths = paths.filter(p => !p.startsWith("particles/"));
    if (paths.length) return paths.join(",");
    return blank;
};

const extraEntities = new Set();
const gameEffectEntities = new Set();

class Spell {
    /** @type {Map<String,Symbol>} */
    static spawnRequiresFlagMap = new Map();
    //prettier-ignore
    static modifierPropAbbrMap = {
//      ä¿®æ­£å±æ€§                    ç®€å†™
        fire_rate_wait           :"frw",
        speed_multiplier         :"spm",
        explosion_radius         :"exr",
        spread_degrees           :"spd",
        pattern_degrees          :"pad",
        
        damage_melee_add         :"dmM",
        damage_projectile_add    :"dmP",
        damage_electricity_add   :"dmL",
        damage_fire_add          :"dmF",
        damage_explosion_add     :"dmE",
        damage_ice_add           :"dmI",
        damage_slice_add         :"dmS",
        damage_healing_add       :"dmH",
        damage_curse_add         :"dmC",
        damage_drill_add         :"dmD",
        damage_overeating_add    :"dmV", // ä¸å­˜åœ¨
        damage_physics_hit_add   :"dmY", // ä¸å­˜åœ¨
        damage_poison_add        :"dmN", // ä¸å­˜åœ¨
        damage_radioactive_add   :"dmR", // ä¸å­˜åœ¨
        damage_holy_add          :"dmO", // ä¸å­˜åœ¨
        damage_critical_chance   :"dcc",
        knockback_force          :"kbf",
        material                 :"mel",
        material_amount          :"mea",
        trail_material           :"tme",
        trail_material_amount    :"tma",
        bounces                  :"boc",
        friendly_fire            :"fyf",
        lifetime_add             :"lft",
        extra_entities           :"exe",
        game_effect_entities     :"gee",
        
        current_reload_time      :"rlt",
        
        recoil_knockback         :"rkb",
    }
    static typeEmojis = ["âš«", "ğŸ”´", "ğŸŸ ", "ğŸ”µ", "âšª", "ğŸŸ¢", "ğŸŸ¡", "ğŸŸ£", "ğŸŸ¤"];
    id;
    name;
    alias;
    desc;
    type;
    maxUse; // è´Ÿæ•°ä»£è¡¨æ— æ³•æ— é™åŒ– 0ä»£è¡¨æ— é™åˆ¶
    mana;
    price;
    passive = "";
    spawnProbs = {};
    spawnRequiresFlag = "";
    draw;
    projectiles;
    action = "";
    nameKey;
    descKey;
    /** @type {CSVData} åˆ«åè¡¨ */
    static _aliasCSV;
    /** @type {CSVData} è§£é”æè¿°è¡¨ */
    static _unlockDescCSV;
    /** @type {CSVData} è¢«åŠ¨æ•ˆæœæè¿°è¡¨ */
    static _passiveDescCSV;
    /** @type {CSVData} (é¢å¤–)æä¾›æŠ•å°„ç‰©è¡¨ */
    static _projectileCSV;
    /** @param {SpellBaseData} data */
    constructor(data) {
        if (data.name.startsWith("$")) {
            this.nameKey = data.name.slice(1);
            this.name = zh_cn(this.nameKey) ?? this.nameKey;
        } else {
            this.nameKey = data.name;
            this.name = data.name;
        }
        if (data.desc.startsWith("$")) {
            this.descKey = data.desc.slice(1);
            this.desc = zh_cn(this.descKey) ?? this.descKey;
        } else {
            this.descKey = data.desc;
            this.desc = data.desc;
        }
        this.alias = Spell._aliasCSV.get(this.name, 1) ?? "";
        if (data.spawnRequiresFlag) {
            const unlockDesc = Spell._unlockDescCSV.get(data.id, 2);
            if (unlockDesc) {
                if (Spell.spawnRequiresFlagMap.has(unlockDesc)) this.spawnRequiresFlag = Spell.spawnRequiresFlagMap.get(unlockDesc);
                else {
                    Spell.spawnRequiresFlagMap.set(unlockDesc, Symbol("$" + (Spell.spawnRequiresFlagMap.size + 1)));
                    this.spawnRequiresFlag = Spell.spawnRequiresFlagMap.get(unlockDesc);
                }
            } else {
                this.spawnRequiresFlag = data.spawnRequiresFlag;
                console.warn(`è§£é”æ¡ä»¶æè¿°ç¼ºå¤± ${data.id}:${data.name}`);
            }
        }
        if (data.passive) {
            const passiveDesc = Spell._passiveDescCSV.get(data.id, 2);
            if (passiveDesc) this.passive = passiveDesc;
            else {
                this.passive = "";
                console.warn(`è¢«åŠ¨æ•ˆæœæè¿°ç¼ºå¤± ${data.id}:${data.name}`);
            }
        }

        // æä¾›æŠ•å°„ç‰© è½¬ä¸ºè¡¨è¾¾å¼
        // æ ¼å¼: æŠ•å°„ç‰©å®ä½“ID:æ•°é‡Hç¢°æ’è§¦å‘æŠ½å–æ•°Då¤±æ•ˆè§¦å‘æŠ½å–æ•°Tå®šæ—¶è§¦å‘æŠ½å–æ•°!å®šæ—¶è§¦å‘å»¶è¿Ÿæ—¶é—´#æä¾›ç±»å‹
        const projectilesCache = [];

        /** å…³è”æŠ•å°„ç‰©xml */
        const relatedProjectileName = data.relatedProjectiles?.[0];
        const relatedProjectileAmount = data.relatedProjectiles?.[1] ?? 1;
        let relatedProjectileHasBeenAdded = false; // é˜²æ­¢é‡å¤è¢«æ·»åŠ 
        for (let i = 0; i < data.projectiles.length; i++) {
            const p = data.projectiles[i];
            // const id = p.id.match(/[\w]+(?=.xml)/)[0].toUpperCase();
            const id = minPath(p.id);
            if (id === blank) continue;
            const cache = [id];

            if (p.min + p.draw_hit + p.draw_death + p.draw_time_count > 1) {
                cache.push(":");
                if (p.min > 1) cache.push(p.min);
                if (p.draw_hit) cache.push("H", p.draw_hit);
                if (p.draw_death) cache.push("D", p.draw_death);
                if (p.draw_time_count) cache.push("T", p.draw_time_count, "!", p.draw_time_delay);
            }
            // ä¸å…³è”æŠ•å°„ç‰©xmlä¸ç›¸åŒæˆ–è€…æ•°é‡ä¸åŒæ—¶å•ç‹¬å£°æ˜å…³è”æŠ•å°„ç‰© (è •è™«é›¨, å¬å”¤è™«å­ç³»åˆ—, ä¾µæ‰°)
            if (p.id !== relatedProjectileName || p.min !== relatedProjectileAmount) {
                if (!cache.includes(":")) cache.push(":");
                cache.push(`#2`); //æä¾›ç±»å‹ä¸ºä»…æ–½æ³•å—
                projectilesCache.push(cache.join(""));
            } else projectilesCache.push(cache.join(""));

            /* å…³è”æŠ•å°„ç‰©å¿…é¡»å­˜åœ¨ */
            if (relatedProjectileName && relatedProjectileName === p.id) {
                relatedProjectileHasBeenAdded = true;
                // å…³è”æŠ•å°„ç‰©æ•°é‡ä¸æ–½æ³•å—æŠ•å°„ç‰©æ•°é‡ä¸ä¸€è‡´æ—¶(å¬å”¤è™«å­ç³»åˆ—, ä¾µæ‰°)
                if (p.min !== relatedProjectileAmount) {
                    if (relatedProjectileAmount > 1) projectilesCache.push(`${id}:${relatedProjectileAmount}#1`);
                    else projectilesCache.push(`${id}:#1`);
                }
            }
        }
        if (!relatedProjectileHasBeenAdded && relatedProjectileName) {
            const id = minPath(relatedProjectileName);
            if (relatedProjectileAmount > 1) projectilesCache.push(`${id}:${relatedProjectileAmount}#1`);
            else projectilesCache.push(`${id}:#1`);
        }

        // å¦‚æœå­˜åœ¨äººå·¥ç»´æŠ¤çš„æŠ•å°„ç‰©æ•°æ®åˆ™ä¸¢å¼ƒè§£ææ•°æ®
        {
            const projectiles = Spell._projectileCSV.get(data.id, 2);
            if (projectiles) {
                projectilesCache.length = 0;
                projectilesCache.push(projectiles);
            }
        }
        
        this.projectiles = projectilesCache.join(" ").trimEnd();

        this.damageMod = Object.assign(new DamageData(""), data.damageMod).toString();
        if (data.gameEffectEntities) this.gameEffectEntities = minPath(data.gameEffectEntities);
        if (data.extraEntities) this.extraEntities = minPath(data.extraEntities);
        this.id = data.id;
        this.type = data.type;
        this.maxUse = data.maxUse ?? 0;
        this.mana = data.mana ?? 10; // è“è€—é»˜è®¤ä¸º10
        this.price = data.price;
        const spwanLevels = data.spwanLevel.split(",").map(Number);
        const spawnProbs = data.spawnProb.split(",").map(Number);
        for (let i = 0; i < spawnProbs.length; i++) this.spawnProbs[spwanLevels[i]] = spawnProbs[i];
        this.draw = data.draw;
        // this.modifierAction = data.modifierAction;
        const modifierAction = data.modifierAction;

        const cache = [];
        // ä½¿ç”¨'#'è¡¨ç¤ºæŠ½å–çš„ä½ç½® ä»¥æ­¤åˆ’åˆ†å‰/åç½®ä¿®æ­£å±æ€§
        let flag_separator = 0;
        for (const e of modifierAction) {
            if (e.pos === "after") {
                if (flag_separator !== 1) {
                    if (cache.at(-1)) cache.pop(); //å–æ¶ˆä¸å¿…è¦çš„';'
                    cache.push("#");
                    flag_separator = 1;
                }
            } else if (e.pos === "before") flag_separator = -1;

            const prop = Spell.modifierPropAbbrMap[e.prop];
            if (["gee", "exe"].includes(prop)) {
                console.log(prop);

                if (prop === "gee") gameEffectEntities.add(e.value);
                if (prop === "exe") extraEntities.add(e.value);
                e.value = minPath(e.value);
                if (e.value.endsWith(",")) e.value = e.value.slice(0, -1);
                if (!e.value) continue;
            }
            if (typeof e.value === "boolean") e.value = Number(e.value);
            if (prop) cache.push(prop, e.type, e.value, ";");
        }
        if (cache.at(-1)) cache.pop(); //å–æ¶ˆä¸å¿…è¦çš„';'
        if (flag_separator < 0) cache.push("#");
        this.modifierAction = cache.join("");
    }

    toString(spread = false) {
        // console.error(this.name, this);

        const alias = this.alias ? this.alias : blank;
        const maxUse = this.maxUse === 0 ? blank : this.maxUse;
        const passive = this.passive ? this.passive : blank;
        const spawnRequiresFlag = this.spawnRequiresFlag ? this.spawnRequiresFlag : blank;
        const draw = this.draw === 0 ? blank : this.draw;
        const projectiles = this.projectiles ? this.projectiles : blank;
        const modifierAction = this.modifierAction ? this.modifierAction : blank;
        const str = JSON5.stringify([
            //===============================[æ„é€ å™¨æ•°æ®ç´¢å¼•]
            this.id, //======================[0] id
            this.name, //====================[1] åç§°
            alias, //========================[2] åˆ«å
            this.desc, //====================[3] æè¿°
            this.type, //====================[4] ç±»å‹
            maxUse, //=======================[5] æœ€å¤§ä½¿ç”¨æ¬¡æ•°
            this.mana, //====================[6] è“è€—
            this.price, //===================[7] å”®ä»·
            passive, //======================[8] è¢«åŠ¨æ•ˆæœ
            this.spawnProbs, //==============[9] ç”Ÿæˆæ¦‚ç‡
            spawnRequiresFlag, //============[10] ç”Ÿæˆæ¡ä»¶
            draw, //=========================[11] æŠ½å–æ•°
            projectiles, //==================[12] æä¾›æŠ•å°„ç‰©
            modifierAction, //===============[13] ä¿®æ­£è¡Œä¸º
            this.action, //==================[14] æ³•æœ¯è¡Œä¸º
            this.nameKey, //=================[15] åç§°é”® ç”¨äºcsvç¿»è¯‘æ˜ å°„
            this.descKey //==================[16] æè¿°é”® ç”¨äºcsvç¿»è¯‘æ˜ å°„
        ]);
        if (spread) return str.slice(1, -1);
        return str;
    }
}

(async () => {
    await langData.ready;
    Spell._aliasCSV = await parseCSVFromUrl("alias.csv");
    Spell._unlockDescCSV = await parseCSVFromUrl("unlockDesc.csv");
    Spell._passiveDescCSV = await parseCSVFromUrl("passiveDesc.csv");
    Spell._projectileCSV = await parseCSVFromUrl("projectile.csv");

    const imgs = await Promise.all(spellBaseDatas.map(e => PNG.removeGAMA(`/${e.icon}`)));

    const canvas = await createSprite(imgs, { size: 16 });
    document.querySelector("#canvas-viewport").append(canvas);

    document.body.append(
        h.button(
            {
                async onclick() {
                    const data = spellBaseDatas.map(e => new Spell(e).toString(true));
                    // console.log(data);

                    const params_str = [...Spell.spawnRequiresFlagMap].map(([data, $var]) => `${$var.description}=${JSON.stringify(data)}`).join(",\n    ");
                    const spells_str = data.join(",\n    ");
                    const comment = getCommentText(`å…±${data.length}æ¡æ³•æœ¯æ•°æ®`);
                    const fileContent = `${comment}\n((\n    ${params_str}\n)=>[\n    ${spells_str}\n])()`;
                    console.log(fileContent);

                    download(fileContent, "spell.data.js");
                    // const cache = [];
                    // for (let i = 0; i < data.length; i++) {
                    //     const d = data[i];
                    //     const base64 = await urlToBase64(imgs[i], 2);
                    //     let alias = "";

                    //     if (d.alias)
                    //         alias = `${d.alias
                    //             .split(" ")
                    //             .map(e => `\`${e}\``)
                    //             .join(",")}`;
                    //     cache.push(`{"name":"${d.id}","description":"**\`${Spell.typeEmojis[d.type]}${d.name}\`**  \\n![](${base64})  \\n${alias}"}`);
                    // }
                    // console.log(cache.join(",\n"));
                }
            },
            "ç”Ÿæˆæ³•æœ¯æ•°æ®"
        ),
        h.button(
            {
                onclick() {
                    const set = new Set(
                        spellBaseDatas
                            .map(e => {
                                const array = [...e.projectiles.map(e => e.id)];
                                if (e.relatedProjectiles) array.push(e.relatedProjectiles[0]);
                                return array;
                            })
                            .flat(2)
                    );
                    const fileContent = `"${[...set].filter(e => Boolean(e)).join(`",\n"`)}"`;
                    download(fileContent, "projectileList.txt");
                }
            },
            "ç”Ÿæˆæ³•æœ¯å¼•ç”¨å®ä½“(æŠ•å°„ç‰©)åˆ—è¡¨"
        ),
        h.button(
            {
                onclick() {
                    download(
                        '"' +
                            [...gameEffectEntities, ...extraEntities]
                                .filter(e => !e.startsWith("particles/"))
                                .map(e => e.slice(0, -1))
                                .join(`",\n"`) +
                            '"',
                        "otherEntities.txt"
                    );
                }
            },
            "ç”Ÿæˆæ³•æœ¯å¼•ç”¨å®ä½“(é¢å¤–å®ä½“,æ¸¸æˆæ•ˆæœå®ä½“)åˆ—è¡¨"
        )
    );
    console.log(gameEffectEntities, extraEntities);
})();
